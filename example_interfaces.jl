############################################################################
##  We discuss the implementation of an algorithm to compute the GIT-fan
##  for torus actions on affine varieties with symmetries based on OSCAR.
##  The algorithm combines computational techniques from commutative algebra,
##  convex geometry and group theory.
##  Applications of the algorithm (using the original implemenation in
##  Singular) include the computation of the Mori chamber decomposition of
##  the moving cone of $\overline{M}_{0,6}$.
##
##  In the following, we discuss Example 5.2 in the paper: 
##
##  [J. Boehm, S. Keicher, Y. Ren:
##  Computing GIT-Fans with Symmetry and the Mori Chamber Decomposition of
##  $\overline{M}_{0,6}$](https://arxiv.org/abs/1603.09241)
##  (To appear in Math. Comp. 2020.)


############################################################################
##  In this session, we use the functions from the Julia module `GITFans.OLD`,
##  from the original implementation of the code which focuses on the
##  interfaces from Julia to GAP, polymake, and Singular.
##  Thus the functions from these systems are called explicitly.
##
##  There is a newer version `example_oscar.jl`, where only Oscar functions
##  are called, delegations to other systems (where necessary) happen
##  at lower levels there.

using Oscar
using GITFans


############################################################################
##  Enter the input data as described in Example 5.2 of the paper.
##
##  Let $K$ be an algebraically closed field of characteristic zero.
##  The Cox ring of $M_{0,5}$ is isomorphic to the coordinate ring
##  $R = K[T_1, \ldots , T_{10}]/\mathfrac{a}$ of the affine cone
##  over the Grassmannian $\mathbb{G}(2, 5)$
##  where the ideal a is generated by the Pl\"ucker relations
##  and the $i$-th row of the matrix $Q$ is the degree
##  $\operatorname{deg}(T_i)\in \mathbb{Z}^5$;
##  this determines the $\mathbb{Z}^5$- grading of $R$.

# grading matrix
Q = [
 1  1   0   0   0 ;
 1  0   1   1   0 ;
 1  0   1   0   1 ;
 1  0   0   1   1 ;
 0  1   0   0  -1 ;
 0  1   0  -1   0 ;
 0  1  -1   0   0 ;
 0  0   1   0   0 ;
 0  0   0   1   0 ;
 0  0   0   0   1 ];

# polynomial ring
R, T = Singular.PolynomialRing(Singular.QQ,
           ["x" * string(i) for i in 1:size(Q, 1)])

# generators for the ideal
a = Singular.Ideal(R, [
    T[5]*T[10] - T[6]*T[9] + T[7]*T[8],
    T[1]*T[9]  - T[2]*T[7] + T[4]*T[5],
    T[1]*T[8]  - T[2]*T[6] + T[3]*T[5],
    T[1]*T[10] - T[3]*T[7] + T[4]*T[6],
    T[2]*T[10] - T[3]*T[9] + T[4]*T[8],
])


############################################################################
##  We observe that there is an $S_5$-symmetry
##  for the $H\cong (\KK^*)^5$-action on $V(\aa)$ where the symmetry group
##  $S_5\cong G\subseteq S_{10}$ is generated by
##  (2,3)(5,6)(9,10), (1,5,9,10,3)(2,7,8,4,6)
##  and represented as a group in GAP.

perms_list = [[1,3,2,4,6,5,7,8,10,9], [5,7,1,6,9,2,8,4,10,3]];
perms = [GAP.Globals.PermList(GAP.julia_to_gap(i)) for i in perms_list];
G = GAP.Globals.Group(GAP.julia_to_gap(perms))


############################################################################
##  We now compute the GIT-fan, represented as a fan in polymake,
##  using Gr√∂bner bases from Singular:

fanobj = GITFans.OLD.git_fan(a, Q, G)


############################################################################
##  We ask polymake to compute its F-vector.

fanobj.F_VECTOR


############################################################################
##  We now go into more details on the computation.
##
##  We compute the orbit cones as projection of a-faces and partition
##  the set of orbit cones into orbits under the symmetry group action.
##  We also return the action on the orbit cones in terms of
##  GAP homomorphisms.

oc = GITFans.OLD.orbit_cone_orbits_and_action(a, Q, G);


############################################################################
##  Lengths of the orbit cone orbits:

map(length, oc["orbit_list"])


############################################################################
##  Action of the symmetry group
##  permuting the elements of the first orbit cone orbit:

oc["homs"][1]


############################################################################
##  We compute the GIT-fan in terms of a set of orbit representatives
##  of maximal dimensional GIT-cones
##  under the action of the given symmetry group,
##  where the GIT-cones are described via hashes encoding the cones
##  as intersections of orbits cones.
##  The data structure also contains the group action on the hashes
##  encoded as GAP homomorphisms.
##
##  The algorithm is based on a fan traversal.
##
##  The function also returns the incidence relation of the orbits of
##  GIT-cones.

(hash_list, edges) = GITFans.OLD.fan_traversal(oc);


############################################################################
##  There are six maximal cones, up to G-symmetry.

length(hash_list)


############################################################################
##  One of the GIT-cones encoded as a hash
##  (the entries of the list correspond to the orbit cone orbits):

hash_list[1]


############################################################################
##  We ask Polymake to create the incidence graph of the orbits,
##  and to visualize it.

intergraph = Polymake.graph.graph_from_edges(collect(edges));
Polymake.graph.visual(intergraph)


############################################################################
##  We translate the descriptions of the six maximal cones back
##  to cone objects and expand their G-orbits.

expanded = GITFans.OLD.orbits_of_maximal_GIT_cones(oc, hash_list);
orbit_lengths = map(length, expanded)


############################################################################
##  There are in total 76 maximal cones.
sum(orbit_lengths)


# ############################################################################
# ##  The full intersection graph of the fan has (76 vertices and) 180 edges.
# ##  (A simpleminded visualization of this graph is not very enlightening.)
#
# maxcones = vcat( expanded... );
# full_edges = GITFans.edges_intersection_graph(maxcones, size(Q, 2) - 1);
# length(full_edges)
# # full_intergraph = Polymake.graph.graph_from_edges(collect(full_edges));
# # Polymake.graph.visual(full_intergraph)


############################################################################
##  We create the GIT-Fan represented by a fan object in polymake:

fanobj = GITFans.OLD.hashes_to_polyhedral_fan(oc, hash_list)


############################################################################
##  We ask polymake to compute its F-vector:

fanobj.F_VECTOR

